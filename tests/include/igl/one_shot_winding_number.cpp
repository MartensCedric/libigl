#include <test_common.h>
#include <igl/one_shot_winding_number.h>
#include <igl/winding_number.h>
#include <igl/bezier_clip.h>
#include <igl/bezier.h>
#include <iostream>

TEST_CASE("one_shot_winding_number: Weighted Sum", "[igl]")
{
  Eigen::MatrixX2d A(5, 2);
  Eigen::VectorXd leftA(5);
  Eigen::VectorXd rightA(5);

  leftA << 0.3, 0.2, 0.1, 0.9, 0.5;
  rightA << 0.7, 0.8, 0.9, 0.1, 0.5;

  A.col(0) = leftA;
  A.col(1) = rightA;

  Eigen::MatrixX2i X(5, 2);
  Eigen::VectorXi leftX(5);
  Eigen::VectorXi rightX(5);

  leftX << 0, 0, 1, 2, -1;
  rightX << 1, -1, 0, 1, 0;

  X.col(0) = leftX;
  X.col(1) = rightX;

  Eigen::VectorXd gt(5);
  gt << 0.7, -0.8, 0.1, 1.9, -0.5;

  Eigen::VectorXd W(5);
  igl::one_shot_winding_number(A, X, W);
  test_common::assert_near(W, gt, 1e-12);
}

TEST_CASE("one_shot_winding_number: cubic bezier", "[igl]")
{
  Eigen::MatrixXd C(4, 2);
  C.row(0) = Eigen::RowVector2d(0.0, 0.0);
  C.row(1) = Eigen::RowVector2d(1.0, 0.0);
  C.row(2) = Eigen::RowVector2d(1.0, 1.0);
  C.row(3) = Eigen::RowVector2d(1.0, 0.0);

  const auto &p0 = C.row(0);
  const auto &p1 = C.row(1);
  const auto &p2 = C.row(2);
  const auto &p3 = C.row(3);

  Eigen::MatrixXd bounds(2, 2);
  bounds << p0.cwiseMin(p1).cwiseMin(p2).cwiseMin(p3),
      p0.cwiseMax(p1).cwiseMax(p2).cwiseMax(p3);

  Eigen::MatrixXd Q(10, 2);

  for (int i = 0; i < 10; i++)
  {
    Q.row(i) = Eigen::RowVector2d(static_cast<double>(i) - 3.0, 0.5);
  }

  Eigen::Matrix<double, Eigen::Dynamic, 1> ts_sq;
  Eigen::MatrixXd normals(0, 2);
  Eigen::RowVector2d Q_row = Q.row(0).head<2>();
  Eigen::RowVector2d dir = (Q.row(1) - Q.row(0)).normalized();
  igl::bezier_clip(Q_row, dir, C, 1e-8, ts_sq, normals);

  std::vector<int> sign(ts_sq.rows());
  for (int k = 0; k < normals.rows(); k++)
  {
    bool same_dir = normals.row(k).dot(dir) > 0.0;
    sign[k] = same_dir ? 1 : -1;
  }

  Eigen::MatrixXi S = Eigen::Map<Eigen::MatrixXi>(sign.data(), sign.size(), 1);
  Eigen::MatrixXd T_sq = Eigen::Map<Eigen::MatrixXd>(ts_sq.data(), ts_sq.size(), 1);

  Eigen::MatrixXd W(10, 1);
  Eigen::MatrixXd endpoints(2, 2);
  endpoints.row(0) = p0;
  endpoints.row(1) = p3;

  igl::one_shot_winding_number(Q, endpoints, T_sq, S, bounds, true, W);

  Eigen::MatrixXd W_no_linear(10, 1);
  igl::one_shot_winding_number(Q, endpoints, T_sq, S, bounds, false, W_no_linear);

  test_common::assert_near(W, W_no_linear, 1e-8);

  const int num_samples = 100;
  Eigen::MatrixXd sampled_points(num_samples, 2);

  for (int i = 0; i < num_samples; i++)
  {
    double t = static_cast<double>(i) / (num_samples - 1);
    Eigen::MatrixXd value;
    igl::bezier(C, t, value);
    sampled_points.row(i) = value;
  }

  Eigen::MatrixXi E(num_samples - 1, 2);
  for (int i = 0; i < num_samples - 1; i++)
  {
    E(i, 0) = i;
    E(i, 1) = i + 1;
  }

  Eigen::MatrixXd W_direct(10, 1);
  for (int i = 0; i < 10; i++)
  {
    Eigen::Matrix<double, 1, 2> q_i = Q.row(i).head<2>();
    W_direct(i) = igl::winding_number(sampled_points, E, q_i);
  }

  test_common::assert_near(W, W_direct, 1e-8);
}

TEST_CASE("one_shot_winding_number: 100 random cubic bezier", "[igl]")
{

  // 100 random cubic bezier curves. Hardcoded for reproducibility.
  // the query points are also along different directions
  Eigen::MatrixXd control_points(400, 2);
  control_points << 0.288602, 0.617703, 0.006744, 0.087885, 0.425661, 0.317362, 0.158457, 0.718262,
      0.183329, 0.819985, 0.401435, 0.027501, 0.876677, 0.619685, 0.047668, 0.919401,
      0.615378, 0.849351, 0.311696, 0.503620, 0.391816, 0.875760, 0.904666, 0.569649,
      0.335651, 0.941729, 0.479478, 0.478159, 0.662344, 0.357855, 0.285588, 0.362656,
      0.656041, 0.871982, 0.455766, 0.028816, 0.535983, 0.429249, 0.933810, 0.822957,
      0.903767, 0.712427, 0.646073, 0.299952, 0.345391, 0.284404, 0.224559, 0.736907,
      0.240798, 0.492464, 0.745089, 0.789237, 0.708096, 0.718116, 0.217165, 0.260661,
      0.427919, 0.440326, 0.463457, 0.180622, 0.993276, 0.110500, 0.093456, 0.212103,
      0.555809, 0.316270, 0.145708, 0.958213, 0.727115, 0.298624, 0.824544, 0.132265,
      0.500941, 0.996232, 0.634263, 0.039677, 0.828705, 0.010267, 0.033884, 0.652350,
      0.174051, 0.917913, 0.076386, 0.224782, 0.143468, 0.623277, 0.896377, 0.653536,
      0.856141, 0.662335, 0.764624, 0.172741, 0.926420, 0.231482, 0.008945, 0.678972,
      0.794163, 0.037355, 0.828709, 0.952022, 0.263034, 0.199501, 0.501212, 0.734363,
      0.607862, 0.765313, 0.200721, 0.831575, 0.696229, 0.912949, 0.900331, 0.463858,
      0.867283, 0.698300, 0.552959, 0.292151, 0.817493, 0.458861, 0.200823, 0.557167,
      0.574188, 0.963766, 0.174316, 0.864490, 0.681492, 0.875220, 0.832091, 0.874776,
      0.511038, 0.989034, 0.953508, 0.880831, 0.085417, 0.186995, 0.973453, 0.910944,
      0.096934, 0.227145, 0.656130, 0.263860, 0.163025, 0.610546, 0.121116, 0.173594,
      0.825779, 0.341507, 0.153443, 0.236415, 0.614023, 0.181248, 0.065276, 0.887507,
      0.321376, 0.632689, 0.932537, 0.383938, 0.840570, 0.674857, 0.162403, 0.063591,
      0.729339, 0.675524, 0.253846, 0.326298, 0.995823, 0.767611, 0.954375, 0.826275,
      0.201289, 0.053962, 0.449951, 0.673677, 0.370922, 0.756784, 0.919365, 0.394205,
      0.801187, 0.588734, 0.827942, 0.998047, 0.987442, 0.222764, 0.211639, 0.722459,
      0.967813, 0.980659, 0.528200, 0.946598, 0.153388, 0.524373, 0.147203, 0.192547,
      0.418890, 0.907967, 0.556451, 0.217618, 0.723180, 0.784815, 0.021020, 0.246017,
      0.420480, 0.711854, 0.181337, 0.259559, 0.907948, 0.755621, 0.540882, 0.508900,
      0.136861, 0.698744, 0.693924, 0.145550, 0.951996, 0.685367, 0.450723, 0.798818,
      0.772053, 0.002595, 0.696708, 0.004598, 0.087528, 0.313104, 0.879715, 0.721065,
      0.592292, 0.249058, 0.642100, 0.501521, 0.545791, 0.679223, 0.808108, 0.831418,
      0.195422, 0.095307, 0.504356, 0.575907, 0.411412, 0.849627, 0.648907, 0.021442,
      0.186469, 0.492387, 0.965622, 0.659520, 0.091797, 0.425675, 0.223192, 0.695887,
      0.876544, 0.810893, 0.978179, 0.341324, 0.154973, 0.238829, 0.184366, 0.174349,
      0.531660, 0.036089, 0.590331, 0.249992, 0.623148, 0.124746, 0.376201, 0.197316,
      0.316888, 0.717308, 0.377107, 0.551924, 0.564678, 0.998546, 0.101658, 0.041004,
      0.899150, 0.913765, 0.591395, 0.689517, 0.607585, 0.539741, 0.523925, 0.085695,
      0.605242, 0.884698, 0.820528, 0.215367, 0.032269, 0.999118, 0.906392, 0.532981,
      0.032379, 0.943798, 0.800623, 0.213536, 0.299522, 0.058752, 0.111550, 0.228101,
      0.150343, 0.423499, 0.551170, 0.977061, 0.283004, 0.573852, 0.832600, 0.642849,
      0.710138, 0.880995, 0.192621, 0.437893, 0.017022, 0.548233, 0.287402, 0.219987,
      0.808773, 0.150730, 0.969027, 0.969991, 0.274833, 0.162983, 0.948623, 0.923597,
      0.430001, 0.229351, 0.954265, 0.098177, 0.729358, 0.440009, 0.859452, 0.036956,
      0.556472, 0.985956, 0.922855, 0.864110, 0.284209, 0.886713, 0.552942, 0.694159,
      0.679457, 0.958180, 0.533545, 0.736142, 0.331101, 0.260749, 0.860689, 0.393179,
      0.571700, 0.847759, 0.904258, 0.850247, 0.679753, 0.809767, 0.446582, 0.748778,
      0.866129, 0.371082, 0.887863, 0.894267, 0.512828, 0.445874, 0.545394, 0.052139,
      0.261662, 0.477541, 0.474542, 0.665211, 0.837234, 0.797780, 0.815018, 0.503144,
      0.700954, 0.387555, 0.788382, 0.757144, 0.960424, 0.844244, 0.052817, 0.344242,
      0.170848, 0.641209, 0.529248, 0.342846, 0.269905, 0.054198, 0.182052, 0.022803,
      0.786633, 0.526823, 0.236936, 0.648517, 0.909780, 0.200403, 0.230161, 0.860275,
      0.112307, 0.958779, 0.404839, 0.787596, 0.755568, 0.949692, 0.341090, 0.499811,
      0.916708, 0.459554, 0.925769, 0.218103, 0.947681, 0.817311, 0.409204, 0.410845,
      0.813425, 0.350839, 0.267236, 0.640909, 0.851992, 0.338625, 0.961665, 0.673149,
      0.283138, 0.964367, 0.944647, 0.309673, 0.317884, 0.507891, 0.447148, 0.762389,
      0.758691, 0.958284, 0.156715, 0.213369, 0.871151, 0.293234, 0.649549, 0.645934,
      0.580285, 0.847090, 0.411067, 0.988492, 0.332037, 0.804101, 0.581298, 0.555876,
      0.084110, 0.424146, 0.394313, 0.422788, 0.216726, 0.147108, 0.968138, 0.065617,
      0.454022, 0.189260, 0.496522, 0.211122, 0.448072, 0.627333, 0.686667, 0.723470,
      0.126287, 0.489846, 0.934941, 0.493506, 0.081943, 0.699470, 0.256464, 0.692093,
      0.369159, 0.987066, 0.492959, 0.567695, 0.421137, 0.135645, 0.049724, 0.617530,
      0.814066, 0.226299, 0.187557, 0.995281, 0.920069, 0.694080, 0.786069, 0.328728,
      0.163229, 0.218583, 0.465935, 0.468816, 0.392019, 0.529270, 0.905205, 0.490780,
      0.526495, 0.339295, 0.012016, 0.179625, 0.856210, 0.367674, 0.089854, 0.393277,
      0.716116, 0.360176, 0.727524, 0.082762, 0.493720, 0.767240, 0.649253, 0.507496,
      0.416291, 0.307109, 0.841467, 0.025007, 0.228253, 0.955559, 0.826853, 0.297867,
      0.560519, 0.943761, 0.036851, 0.445885, 0.978120, 0.043849, 0.931684, 0.852499,
      0.862301, 0.469789, 0.781440, 0.362316, 0.521175, 0.487015, 0.547853, 0.285775,
      0.244505, 0.604240, 0.693943, 0.376041, 0.319474, 0.385299, 0.578136, 0.969709,
      0.789762, 0.612479, 0.848969, 0.054081, 0.507094, 0.756069, 0.734094, 0.430504,
      0.333420, 0.576410, 0.575015, 0.897320, 0.534195, 0.115301, 0.972116, 0.038746,
      0.312594, 0.565122, 0.508495, 0.167623, 0.006526, 0.429435, 0.725347, 0.771188,
      0.730284, 0.636267, 0.577873, 0.880883, 0.801469, 0.623011, 0.996816, 0.616919,
      0.167992, 0.490306, 0.869688, 0.804992, 0.281021, 0.001745, 0.842377, 0.714268,
      0.525860, 0.126333, 0.473210, 0.512899, 0.588371, 0.587947, 0.362396, 0.674483,
      0.821441, 0.981740, 0.264519, 0.622269, 0.326619, 0.596710, 0.529727, 0.300704,
      0.248513, 0.938504, 0.227446, 0.493849, 0.881940, 0.915144, 0.666075, 0.330694,
      0.955891, 0.499180, 0.022152, 0.844696, 0.352866, 0.009670, 0.281678, 0.014121,
      0.817556, 0.305094, 0.606542, 0.895615, 0.002318, 0.411470, 0.561742, 0.300974,
      0.077453, 0.304332, 0.940081, 0.489937, 0.235817, 0.187473, 0.375916, 0.680108,
      0.582400, 0.441784, 0.773159, 0.583182, 0.191505, 0.436164, 0.939643, 0.305628,
      0.393029, 0.672630, 0.139012, 0.370939, 0.785597, 0.020747, 0.002111, 0.659533,
      0.387166, 0.991587, 0.862224, 0.595830, 0.286370, 0.194979, 0.843824, 0.831137,
      0.447081, 0.032510, 0.255344, 0.032123, 0.952439, 0.775033, 0.413103, 0.794774,
      0.357692, 0.678235, 0.811731, 0.012327, 0.707767, 0.784718, 0.101612, 0.214315,
      0.231461, 0.888168, 0.264478, 0.847145, 0.724104, 0.307438, 0.621244, 0.320339,
      0.149850, 0.028420, 0.216821, 0.273142, 0.131840, 0.174496, 0.016768, 0.380410,
      0.277993, 0.868597, 0.743780, 0.483182, 0.280592, 0.431993, 0.598645, 0.465301,
      0.038694, 0.937154, 0.064775, 0.153010, 0.854910, 0.507457, 0.541843, 0.111036,
      0.234226, 0.446735, 0.676688, 0.876122, 0.790042, 0.402948, 0.564609, 0.482718,
      0.617886, 0.038939, 0.753864, 0.818502, 0.468186, 0.023389, 0.789798, 0.552389,
      0.162482, 0.546461, 0.897968, 0.500765, 0.308865, 0.047561, 0.441288, 0.815141,
      0.070024, 0.899567, 0.230963, 0.399178, 0.379202, 0.136926, 0.408805, 0.932197,
      0.337446, 0.307110, 0.688509, 0.331418, 0.669923, 0.666204, 0.184606, 0.296510,
      0.852997, 0.747974, 0.424424, 0.690044, 0.681540, 0.438534, 0.610137, 0.193162,
      0.636578, 0.393582, 0.584637, 0.716197, 0.721481, 0.521939, 0.543125, 0.890192,
      0.696829, 0.768567, 0.758472, 0.504060, 0.745518, 0.222746, 0.621765, 0.527078,
      0.021755, 0.504806, 0.755501, 0.216828, 0.430668, 0.469711, 0.281260, 0.783809,
      0.328357, 0.039444, 0.568738, 0.533814, 0.075512, 0.992363, 0.388703, 0.711755,
      0.704204, 0.488470, 0.103310, 0.446789, 0.022857, 0.122281, 0.250768, 0.906230,
      0.158064, 0.658979, 0.014366, 0.645981, 0.632014, 0.917214, 0.390840, 0.589892,
      0.325414, 0.232315, 0.835085, 0.920484, 0.921522, 0.719612, 0.198039, 0.423455;

  for (int k = 0; k < 100; k++)
  {
    std::cout << "k: " << k << std::endl;
    Eigen::MatrixXd C(4, 2);
    C.row(0) = control_points.row(k * 4);
    C.row(1) = control_points.row(k * 4 + 1);
    C.row(2) = control_points.row(k * 4 + 2);
    C.row(3) = control_points.row(k * 4 + 3);

    std::cout << "C: " << C << std::endl;

    const auto &p0 = C.row(0);
    const auto &p1 = C.row(1);
    const auto &p2 = C.row(2);
    const auto &p3 = C.row(3);

    Eigen::MatrixXd bounds(2, 2);
    bounds << p0.cwiseMin(p1).cwiseMin(p2).cwiseMin(p3),
        p0.cwiseMax(p1).cwiseMax(p2).cwiseMax(p3);

    Eigen::MatrixXd Q(10, 2);

    for (int i = 0; i < 10; i++)
    {
      // Query points along a line that has a slope of theta
      double theta = static_cast<double>(k)/ (2.0 * M_PI);
      double t_i = -1.0 + (2.0 * static_cast<double>(i)) / 9.0; // -1.0 to 1.0

      Q.row(i) = Eigen::RowVector2d(0.5 + 0.5 * t_i * std::cos(theta), 0.5 + 0.5 * t_i * std::sin(theta));
    }


    std::cout << "Q: " << Q << std::endl;

    Eigen::Matrix<double, Eigen::Dynamic, 1> ts_sq;
    Eigen::MatrixXd normals(0, 2);
    Eigen::RowVector2d Q_row = Q.row(0).head<2>();
    Eigen::RowVector2d dir = (Q.row(1) - Q.row(0)).normalized();
    igl::bezier_clip(Q_row, dir, C, 1e-10, ts_sq, normals);

    std::vector<int> sign(ts_sq.rows());
    for (int k = 0; k < normals.rows(); k++)
    {
      bool same_dir = normals.row(k).dot(dir) > 0.0;
      sign[k] = same_dir ? 1 : -1;
    }

    Eigen::MatrixXi S = Eigen::Map<Eigen::MatrixXi>(sign.data(), sign.size(), 1);
    Eigen::MatrixXd T_sq = Eigen::Map<Eigen::MatrixXd>(ts_sq.data(), ts_sq.size(), 1);

    Eigen::MatrixXd W(10, 1);
    Eigen::MatrixXd endpoints(2, 2);
    endpoints.row(0) = p0;
    endpoints.row(1) = p3;

    igl::one_shot_winding_number(Q, endpoints, T_sq, S, bounds, true, W);

    Eigen::MatrixXd W_no_linear(10, 1);
    igl::one_shot_winding_number(Q, endpoints, T_sq, S, bounds, false, W_no_linear);

    test_common::assert_near(W, W_no_linear, 1e-8);

    const int num_samples = 250;
    Eigen::MatrixXd sampled_points(num_samples, 2);

    for (int i = 0; i < num_samples; i++)
    {
      double t = static_cast<double>(i) / (num_samples - 1);
      Eigen::MatrixXd value;
      igl::bezier(C, t, value);
      sampled_points.row(i) = value;
    }

    Eigen::MatrixXi E(num_samples - 1, 2);
    for (int i = 0; i < num_samples - 1; i++)
    {
      E(i, 0) = i;
      E(i, 1) = i + 1;
    }

    Eigen::MatrixXd W_direct(10, 1);
    for (int i = 0; i < 10; i++)
    {
      Eigen::Matrix<double, 1, 2> q_i = Q.row(i).head<2>();
      W_direct(i) = igl::winding_number(sampled_points, E, q_i);
    }

    test_common::assert_near(W, W_direct, 1e-8);
  }
}